---
author: "Andrey Merkurev"
linktitle: "docopt - единый подход к разбору аргументов командной строки"
title: "docopt - единый подход к разбору аргументов командной строки на C++, Python и Java"
publishDate: 2015-11-06T23:22:00+03:00
date: 2015-11-06T23:22:00+03:00
draft: false
tag: "c++, python, java, docopt, commandline, args, program_options"
oldLink: "/article/view/22/"
---


Доводилось ли Вам писать код, который разбирает аргументы, переданные программе в командной строке? Думаю, ответ \- да. Одни программисты предпочитают использовать специализированные инструменты, такие как [Boost.Program_options](http://www.boost.org/doc/libs/1_59_0/doc/html/program_options.html) в С++, или [Commons CLI](http://commons.apache.org/proper/commons-cli/index.html) в Java. Другие же разработчики неустанно пишут свои собственные "парсеры" аргументов командной строки.

Что мы имеем в итоге? Если в компании программисты трудятся на разных языках, то скорее всего они будут использовать разные подходы к решению данной задачи. Хорошо если выработано общее соглашение о том, в каком виде программы должны принимать аргументы. Например, как выглядит _короткая (-h) и полная (--help)_ форма для настройки,  какие ключи за что отвечают, и так далее. Такие требования не всегда существуют, как и документация по допустимым параметрам запуска. Реализации "парсеров" ведут себя по-разному, и не всегда хорошо написаны. Беспорядок и неразбериха...

Оказывается, эту проблему можно элегантно и исключительно быстро решить раз и навсегда. В этом поможет проект [docopt](http://docopt.org). Это унифицированный и эффективный подход к разбору аргументов командной строки для любого языка (практически).

Что такое docopt? Во-первых, это общепринятое соглашение о том, как должен выглядеть command-line интерфейс программы.

На [этой странице](http://try.docopt.org) Вы можете немного поэкспериментировать. На ней описан интерфейс к вымышленной программе (а-ля "морской бой") на естественном языке, и Вы можете легко изменить его под себя. При  этом нужно следовать простым правилам описания, которые приведены на [странице](http://docopt.org) проекта. Затем, в строке **argv **введите аргументы и нажмите **run**. В итоге, Вы получите значения всех аргументов в удобном виде (json). Точно также, Вы сможете получить их впоследствии в своей программе. Таким образом, **docopt** \- это соглашение о том, как должен выглядеть интерфейс командной строки в общем виде. То самое соглашение, которое так часто отсутствует между программистами. При этом docopt ничего не придумывал нового. Это то самое соглашение, которое принято в сообществе для описания аргументов приложения в man-страницах и help-справке. Этому соглашению люди следуют много лет. Этому опыту можно доверять.

  

Во-вторых, **docopt** \- это микро-библиотека, написанная для большого числа языков, которая способна по строке с описанием интерфейса, реализовать необходимый разбор аргументов!

В результате, всё что Вам нужно \- это создать простой текстовый файл с описанием интерфейса командной строки, по правилам docopt. Приятно, что описывается интерфейс полностью на естественном языке, что позволяет перенести это описание как есть в документацию для пользователя. Если бы изначальным форматом был json, xml или даже yaml - то его бы пришлось адаптировать, прежде чем копировать в документацию.

Далее, полученный файл нужно передать тем программистам, которые будут реализовывать описанный интерфейс. Они, предварительно подключив реализацию **docopt** на любимом языке, должны просто направить содержимое файла "парсеру", вместе с переданными аргументами. Всё остальное сделает docopt.

Он проверит: корректные были переданы аргументы или нет, допустимы ли такие комбинации аргументов или нет, и так далее. Если разбор оказался успешным, то мы получим все настройки в удобной, для дальнейшей обработки, форме.

  

А теперь короткий пример всего вышеописанного сразу для трёх языков.

(я не буду рассказывать как подключить **docopt** в свою программу, потому что, это точно тоже самое, что и подключить любую другую библиотеку на соответствующем языке)

Итак, пример описания интерфейса возьмём с официального сайта, и поместим его в файл **cli.docopt** (имя может быть любым).  Содержимое файла **cli.docopt**:
```
Naval Fate.

Usage:
  naval_fate.py ship new <name>...
  naval_fate.py ship <name> move <x> <y> [--speed=<kn>]
  naval_fate.py ship shoot <x> <y>
  naval_fate.py mine (set|remove) <x> <y> [--moored|--drifting]
  naval_fate.py -h | --help
  naval_fate.py --version

Options:
  -h --help    Show this screen.
  --version    Show version.
  --speed=<kn> Speed in knots [default: 10].
  --moored     Moored (anchored) mine.
  --drifting   Drifting mine
```
Теперь этот файл можно использовать в программе, написанной на Python, для разбора аргументов командной строки. Предварительно нужно установить в системе [модуль docopt](https://github.com/docopt/docopt). Вот как может выглядеть простой скрипт на Python, способный "разобраться" в переданных аргументах.
```
# encoding: utf-8
# Модуль: docopt_test

from docopt import docopt


if __name__ == '__main__':
    
  cli = open('cli.docopt').read()  # Чтение содержимого файла cli.docopt

  # Разбор аргументов
  arguments = docopt(cli, help=True, version='Naval Fate 3.0.1')  

  print(arguments)  # Полезная работа с аргументами
```
Примеры запуска:

**$ python docopt_test.py --version**
<pre>
Naval Fate 3.0.1
</pre>

**$ python docopt_test.py ship shoot 100 200**
```
{ 
    '--drifting': False, 
    '--help': False, 
    '--moored': False, 
    '--speed': '10', 
    '--version': False, 
    '<name>': [], 
    '<x>': '100', 
    '<y>': '200', 
    'mine': False, 
    'move': False, 
    'new': False, 
    'remove': False, 
    'set': False,
    'ship': True, 
    'shoot': True 
}
```

**$ python docopt_test.py**
```
Usage:
  naval_fate.py ship new <name>...
  naval_fate.py ship <name> move <x> <y> [--speed=<kn>]
  naval_fate.py ship shoot <x> <y>
  naval_fate.py mine (set|remove) <x> <y> [--moored|--drifting]
  naval_fate.py -h | --help
  naval_fate.py --version
```
Вся работа с docopt в программе заняла 2 строки кода! Поэтому мы можем сосредоточиться на описании интерфейса, а не на его реализации. И пусть интерфейс будет сложным, нам всё равно не придется его реализовывать вручную. К тому же мы всегда будем иметь понятное и полное описание. Это описание подходит и "парсеру", и пользователю - это удобно!

Вот как можно работать с docopt на C++ (файл cli.docopt тот же самый):
```
// Файл main.cpp

#include <fstream>
#include <streambuf>
#include <iostream>

#include "docopt.h"

int main(int argc, const char * argv[])
{
  typedef std::istreambuf_iterator<char> it_type;

  bool help = true;
  std::string version = "Naval Fate 3.0.1";

  // Чтение содержимого файла cli.docopt  
  std::ifstream f("cli.docopt");
  std::string cli((it_type(f)), it_type()); 

  // Разбор аргументов (почти как в Python)  
  std::map<std::string, docopt::value> args = docopt::docopt(
    cli, { argv + 1, argv + argc }, help, version);

  // Полезная работа с аргументами   
  for(auto const& arg : args) {
    std::cout << arg.first << ": " << arg.second << std::endl;
  }

  return 0;
}
```
Ну что тут сказать... чтение из файла получилось чуть длиннее, чем в Python. В остальном всё осталось также очень просто. Следует иметь ввиду, что реализация docopt для C++ использует возможности из нового стандарта С++11. Поэтому Ваш компилятор должен поддерживать этот стандарт. [Библиотека](https://github.com/docopt/docopt.cpp) состоит всего из одного файла docopt.cpp и нескольких заголовочных файлов. Таким образом, docopt можно компилировать сразу вместе с Вашим проектом. Например, так:

**$ clang++ --std=c++11 --stdlib=libc++ docopt.cpp main.cpp -o docopt_test**

Разбор аргументов на С\+\+ работает точно также, как и в Python. Если Вы внесёте изменения в файл cli.docopt, то Вы фактически перенастроите работу "парсера" как в С++, так и в Python, при этом просто изменив человекочитаемое описание интерфейса. Сам код менять не придется. Это удобно!

С\+\+ программисты конечно могут возмутиться, и сказать, что используя [Boost.Program_options](http://www.boost.org/doc/libs/1_59_0/doc/html/program_options.html), можно реализовать всё тоже самое. Однако, нужно иметь ввиду, что кода в этому случае придётся написать намного больше. Особенно сложно будет сделать его универсальным и гибким, способным быстро адаптироваться к новым настройкам. С docopt писать код парсера вообще не нужно. Какой бы сложности интерфейс командной строки не был. Это касается не только С++, но и других языков, например, Java.

Пример кода на Java, который разбирает аргументы с помощью docopt.
```
import java.util.Map;
import java.util.Scanner;
import java.io.File;

import org.docopt.Docopt;


public class DocoptTest {

  public static void main(String[] args) {

    // Чтение содержимого файла cli.docopt
    String cli = 
      new Scanner(new File("cli.docopt")).useDelimiter("\\Z").next();

    // Разбор аргументов (почти как в Python и C++)
    Map<String, Object> opts =
      new Docopt(cli).withVersion("Naval Fate 3.0.1").parse(args);

    // Полезная работа с аргументами
    System.out.println(opts);
      
  }
}
```
Пример очень похож на два предыдущих (почти такой же, как и для Python). [Пакет Docopt](https://github.com/docopt/docopt.java) легко подключить и использовать. Из особенностей то, что он был протестирован с Java 6 и 7. Но с Java 8 также не должно быть проблем. Обратите внимание, файл cli.docopt не менялся ни в одном из примеров. Определив один раз интерфейс командной строки, мы следуем ему в независимости от языка программирования. cli.docopt легко изменять по необходимости, а код парсера и вовсе не нуждается в изменениях. Имеется прекрасная возможность протестировать интерфейс на этой странице [try.docopt.org](http://try.docopt.org).

Можно и дальше приводить примеры для языков [Go](https://github.com/docopt/docopt.go), [C#](https://github.com/docopt/docopt.net), [Ruby](https://github.com/docopt/docopt.rb), и многих других. С полным списком реализаций Вы сможете ознакомиться странице [github.com/docopt](https://github.com/docopt). Если Ваш любимый язык отсутствует в списке, то возможно вскоре он появится. Проект активно развивается, и это очень хорошо. Все ошибки быстро исправляются.

Вместо заключения, хотелось бы сказать, унификация инструментов в программировании \- очень полезный процесс. Возможно Вы знакомы с проектом [Protobuf](https://en.wikipedia.org/wiki/Protocol_Buffers) или [Thrift](https://en.wikipedia.org/wiki/Apache_Thrift). Эти инструменты позволяют сериализовать данные на одном языке так, что десериализовать их обратно можно на любом другом языке. В результате, программа на C++ легко может передать объект в программу на Go или Node.js. Фактически, становится не так важно на чем Вы пишите. Выработанные соглашения соблюдаются в любой реализации. В какой-то степени - всё это напоминает паттерны проектирования, которые помогают решать архитектурные задачи, возникающие снова и снова. Паттерны абстрагированы от конкретного языка программирования (обычно), и если Вы перейдёте на использование другого языка, они снова окажутся Вам полезны. Их не придется выучивать повторно. То же можно сказать и про Docopt. Этот проект заслуживает внимания, и он будет полезен на каком бы языке Вы не писали.
