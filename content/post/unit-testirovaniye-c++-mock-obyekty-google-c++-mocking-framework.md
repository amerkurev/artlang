---
author: "Andrey Merkurev"
linktitle: "Unit-тестирование и C++: что такое mock-объекты"
title: "Unit-тестирование и C++: что такое mock-объекты на примере Google C++ Mocking Framework"
publishDate: 2015-10-13T00:11:00+03:00
date: 2015-10-13T00:11:00+03:00
draft: false
tag: "c++, unit-test, unittest, mocking, framework, google, test"
oldLink: "/article/view/14/"
---


Модульное тестирование  (unit testing) в первую очередь помогает нам получить код, который в будущем "не страшно" будет изменить: внести новую функциональность, переписать ради повышения производительности, исправить ошибки. Разработка таких тестов  - прямая обязанность авторов кода, а сам процесс - это не что иное, как программирование. И, зачастую, разработка модульных тестов сопоставима и по времени и по сложности с разработкой тестируемого кода. Особенно, когда "дизайн" программы плохо продуман (например, запутанные связи между классами). 

Цель модульного тестирования \- проверить отдельные "единицы" программы, например, методы класса. При этом тест не должен "выходить за рамки" этих методов. Но это проще сказать, чем сделать.

Классы, очень часто используют в своей реализации другие классы, а те в свою очередь включают еще множество классов. Так как практически все программы используют библиотеки и различные платформы \- подобная ситуация закономерна. Редкая функция изолирована полностью от "остального мира" \- но этот мир не должен охватываться одним модульным тестом!

Возникает вопрос: как в этом случае писать тесты, как абстрагироваться от зависимостей? Ответ: использовать **mock-объекты**. Данная статья включает краткий обзор применения mock-объектов в тестировании с использованием библиотеки **Google C++ Mocking Framework**.

### **Инструмент**

Условимся, что читатель использует одну из библиотек на С++, предназначенную для написания модульных тестов, или хотя бы знаком с процессом разработки таких тестов. Если же нет, то вот [хорошая статья](http://gamesfromwithin.com/exploring-the-c-unit-testing-framework-jungle), в которой рассматриваются некоторые популярные библиотеки. Правда, в этот обзор не вошла библиотека "Google C++ Testing Framework" (далее просто **Google Test**). Почему? Возможно, потому что Google Test разрабатывается с 2008 года, а статья написана в 2004. 

Назначение Google Test тоже, что и у Boost.Test или CppUnit - разработка модульных тестов. Любая из этих библиотек прекрасно справляется с данной задачей. Однако, в состав Google Test входит особое дополнение, которое называется "Google C++ Mocking Framework" (_конкретно в данной статье не делается существенных различий между понятиями "фреймворк" и "библиотека" \- прошу извинить_).  Google C++ Mocking Framework (далее просто **Google Mock**) не может работать отдельно от Google Test, поэтому если соберетесь использовать этот инструмент, придется собрать оба проекта. Это не сложно. В целом по проекту есть хорошая документация (и на русском тоже), около 800 вопросов с тегом Google Test на [stackoverflow](http://stackoverflow.com/questions/tagged/googletest), достаточное количество статей. Мы будем рассматривать Google Mock, который позволяет создавать и задействовать в модульных тестах mock-объекты.

Чтобы понять, зачем нужны mock-объекты в модульно тестировании, нам понадобится простой пример.

### **Задача**

Представим, что мы разрабатываем класс под названием **Order** (Заказ пользователя), и в нём есть несколько функций-членов: **check **\- для проверки заказа, **payment** \- для оплаты заказа, **cancel** \- для отмены и еще много всего, что может быть связано с заказом. Допустим, что реализация методов очень даже нетривиальная. Модульные тесты должны проверить \- корректно ли отрабатывают данные функции на различном наборе входных данных. Задача стандартная. Однако, есть нюанс...

Внутри реализации методов класса Order, используется объект класса **Database** (База данных). Этот класс инкапсулирует общение с неким хранилищем данных, и каждая операция из Order, инициирует обращение к этому хранилищу. Класс Database выполняет неизвестную нам "магию", требует "живую" базу данных, и вообще проектируется не нами, а другим отделом. Наши модульные тесты для Order не должны проверять еще и класс Database. Более того, нет никакого желания ради тестов настраивать настоящую базу данных. Поэтому от реального класса Database нужно избавиться - заменить его на некую "пустышку", пародию, которая имеет точно такой же интерфейс как и Database, но в действительности ничего не делает или делает, то что нужно нам в тесте.

_Примечание: возможно Вы раскритикуете подобную связь между классами Order и Database, но поймите правильно - это только пример._

Ниже условно представлены классы, о которых идет речь: Database и Order.
```
/**
 * Класс Database используется для работы с хранилещем данных.
 */

class Database
{
public:

    // make_query - метод, инициирующий запрос к хранилищу.
    // 
    // query - строка с конкрентным запросом;
    // result - данные из хранилища, полученные 
    // в результате выполнения запроса;
    // 
    // Если запрос успешно обработан, то возвращаемое значение равно true.
    //
    bool make_query(std::string const& query, std::string& result);
};
```
```
/**
 * Шаблон класса Order представляет собой заказ.
 * В качестве параметра шаблона ожидается тип для работы с хранилищем данных.
 * В общем случае это не обязательно класс Database.
 */

template <class DatabaseType>
class Order
{
public:

    Order(DatabaseType *db_) : db(db_) { /*...*/ }

    // Метод для проверки заказа 
    bool check(int64_t); 
    { 
        //...
        db->make_query(query, result); // Обращение к хранилищу данных
        //...
    }

    // Метод для оплаты заказа
    bool payment(int64_t) 
    { 
        //...
        db->make_query(query, result);
        //...
    }

    // Метод для отмены заказа
    bool cancel(int64_t) 
    { 
        //...
        db->make_query(query, result);
        //...
    }

private:
    DatabaseType *db; // Некий объект, исполняющий запросы к хранилищу данных.
};
```
Класс Order может работать с разными реализациями Database, а раз нам нужно сделать "пустышку", то почему бы не реализовать это самим - не прибегая к помощи Google Mock. Просто создадим свой класс **DatabaseDummy**, с открытым интерфейсом как у Database, и будем использовать его в тестах. Это логичная идея, но она не подходит для тестирования. И вот почему:

1) класс DatabaseDummy нужно разрабатывать. Да - это всего лишь эмуляция, но даже её утомительно писать. Можно где-то "посадить" ошибку - это нудный и бесполезный процесс.

2) класс DatabaseDummy не просто должен что-то делать, он должен уметь демонстрировать различное поведение, так будто он настоящий Database. А это поведение должно легко описываться в конкретном тесте. Другими словами, класс DatabaseDummy должен вести себя не как "пустышка", которая всегда отвечает одинаково. А этого сложнее добиться.

Описанный класс DatabaseDummy - это **fake-класс**, но не **mock-класс**. А у этих понятий разный смысл. Можно конечно довести класс DatabaseDummy до того состояния, когда он удовлетворит нашим требованиям, но в итоге мы получим дополнительный код, который также нужно тестировать (вот блин). А если у Вас, кроме Database, в реализации задействованы еще и другие объекты, например для работы с сетью? Сколько придется потратить времени, сколько мы еще напишем кода? Если же задействовать Google Mock, то всё станет намного проще. Google Mock предоставит нам готовые mock-классы с минимальными затратами сил с нашей стороны.

### **Решение**

Как будет выглядеть полноценный управляемый mock-класс для класса Database, если доверить это Google Mock? Вот так:
```
/**
 * Mock-класс для Database. 
 * Это всё, что нам нужно написать. 
 * 
 * Волшебные макросы MOCK_METHODx (где x количество аргументов функции) 
 * автоматически сгенерируют методы, которые нам нужны. Вот и всё!
 */
class MockDatabase
{
public:
    MOCK_METHOD2(make_query, bool(std::string const& query, std::string& result));
};
```
Если Вы что-то напишите неправильно, то получите ошибку на этапе компиляции, и это очень хорошо.

В документации описано, как создавать mock-классы для разных случаев. Например, если используются не шаблоны, а наследование. Но на деле, процесс обучения созданию mock-классов с помощью Google Mock занимает несколько минут. На много интереснее затем использовать их в тестах, так как их поведение полностью подчинено нам. Кроме управления mock-объектами, можно (и даже нужно) указать их предполагаемое использование - сколько раз за тест метод должен вызываться, какие аргументы ему должны быть переданы. Если что-то из заданных предположений не выполнится, тест не будет считаться пройденным. Перейдем к простому примеру. 

Протестируем метод **check** из класса Order. Вместо Database будем использовать MockDatabase. Проверим, что метод **make_query **класса MockDatabase (а следовательно и класса Database), будет вызван за тест только один раз. При этом значение первого передаваемого аргумента должно быть равно "query", а второй аргумент, в момент вызова make\_query, нас не интересует. Однако, в результате вызова make\_query, второй аргумент должен быть установлен в "result", а сам метод должен вернуть true.
```
/**
 * Тестируем метод check.
 */

using ::testing::_;
using ::testing::SetArgReferee;
using ::testing::DoAll;
using ::testing::Return;


TEST(OrderTest, check)
{
    // Создаем mock-объект, который заменит Database
    MockDatabase database; 
    
    // Макрос EXPECT_CALL позволяет описать, 
    // что должно произойти с методом make_query за время теста:
    //
    // а) метод make_query должен быть вызван строго один раз (WillOnce)
    // б) методу make_query в качестве первого аргумента передадут "query"
    // в) что передадут в качестве второго аргумента не важно
    // г) метод make_query установит второй аргумент в значение "result"
    // д) метод make_query вернет true
    
    // Запомните: это только описание того, что еще должно произойти в тесте!
    
    EXPECT_CALL(database, make_query("query", _))
        .WillOnce(DoAll(SetArgReferee<1>("result"), Return(true)));

    
    // Создаем экземпляр класса Order
    Order<MockDatabase> order(&database); 
    
    
    // Проверяем метод check и все сделанные предположения относительно 
    // метода make_query. При этом make_query внутри метода check будет
    // вести себя так, как мы ему указали. А все предположения относительно
    // количества вызовов и аргмументов будут строго проверены.

    order.check(100); // ... здесь начинаются реальные действия
}
```
### **Результат**

На первый взгляд выражение EXPECT\_CALL кажется сложным и перегруженным. Однако, нам удалось одной строкой описать поведение метода make\_query из класса Database (MockDatabase) в данном конкретном тесте. Кроме поведения, мы определили ряд предположений относительно того, как будет происходить использование метода make\_query: количество вызовов, значения передаваемых аргументов. И всё в одной строке. На самом деле реальный тест имел бы множество EXPECT\_CALL выражений, описывал бы и другие методы класса Database, определял бы последовательность их вызовов.

Возможности Google Mock в описании предполагаемого поведения mock-объектов очень обширны. **SetArgReferee**, **DoAll**, **Return** \- это функции из библиотеки Google Mock. [Полный список](https://code.google.com/p/googlemock/wiki/CheatSheet) их велик, но благодаря им можно задавать очень сложное поведение для своих mock-объектов. Однако, во многих случаях вполне хватит и 10% того, что есть у Google Mock. 

Обратите внимание, что поведение не "зашито" в mock-объекте, а задается в начале очередного теста. Это позволяет гибко настраивать каждый отдельный тест. Например, в следующем примере мы ожидаем, что метод make_query вообще не будет вызван:
```
TEST(OrderTest, cancel)
{
    MockDatabase database; // mock-объект всё тот же
    
    // Метод make_query не должен вызываться в этом тесте, 
    // иначе тест не пройден
    EXPECT_CALL(database, make_query(_, _)).Times(0);

    Order<MockDatabase> order(&database);
    
    order.cancel(1);
}
```
Основная мысль заключается в том, что используя mock-объекты, мы сосредотачиваемся не на их реализации, а на их поведении, и ожиданиях, относительно использования в тесте. Мы как бы описываем "внешнюю среду" для тестируемого кода, изолируем его от всех зависимостей, но имитируем всё так, как будто "внешняя среда" существует (библиотеки, базы данных, сеть). Можно даже создавать исключительные ситуации, которые сложно воспроизвести в реальности.

### **Итог**

К счастью, многие разрабатывают модульные тесты для своих программ. Но далеко не всегда при это люди знают про mock-объекты. Или называют их просто "пустышками", упуская возможности, которые они предоставляют. Библиотеки для создания и управления mock-объектами существуют в любом языке. Например, в питоне (с версии 3.3) есть стандартный модуль **unittest.mock**. В java есть **JUnit** и расширение **JMock**. Даже для языка C есть библиотека [cmocka.org](https://cmocka.org/), которая поддерживает mock-объекты. Google C++ Mocking Framework не уступает им в возможностях, но остается достаточно простым в использовании.

Целью статьи было обратить Ваше внимание на возможности применения mock-объектов в модульном тестировании. Кратко рассказать об одном из эффективных инструментов.