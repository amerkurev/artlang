---
author: "Andrey Merkurev"
linktitle: "Интересная задача на собеседовании"
title: "Интересная задача на собеседовании"
publishDate: 2014-11-17T21:58:00+03:00
date: 2014-11-17T21:58:00+03:00
draft: false
tag: "c++, hash, std, max_load_factor"
oldLink: "/article/view/6/"
---


Однажды, на собеседовании в крупной российской IT компании, было предложено решить одну интересную задачу. Точный текст условия, к сожалению, привести нет возможности, однако суть задачи простая. 

**Задача**

Пусть дана последовательность **целых** чисел. Длина последовательности известна. Числа **не отсортированы** и могут повторяться. Необходимо найти в данной последовательности такие два числа Mи N, чтобы их сумма была равна целому числу K ( M + N = K ). Будем считать, что K равно 5. Хотя можно выбрать любое другое целое число.

Для примера, возьмем последовательность (1):
<pre>
7, -1, 1, -7, 0, -4, 3, 2, -5, -6, 8, -2  (1)

Тогда M = 3, а N = 2 ( 3 + 2 = 5 ), 
или   M = 7, а N = -2 ( 7 + (-2) = 5 )
</pre>
Для решения задачи достаточно найти хотя бы одну подходящую пару чисел M и N. Ограничения по памяти не накладываются и главным критерием является асимптотическая сложность алгоритма. Решим эту задачу.

Программировать будем на C++. Хотя решение на другом языке не будет сильно отличаться. Для всех вариантов решения будем приводить описание алгоритма и пример кода.

### **Вариант 1, медленный: O(n^2)**

Первое что приходит на ум и о чем лучше не говорить в слух \- это метод полного перебора и сравнения каждого элемента с другими элементами последовательности. В этом случае действуем так: берем первый элемент и начинаем искать во всей входной последовательности такой элемент, чтобы в сумме с первым получилось 5 (число K). Если ничего не найдено, берем второй элемент и снова проходим всю последовательность, начиная с третьего элемента, в поисках подходящей пары. Как только пара будет найдена, алгоритм останавливается. Иначе продолжаем искать. 

Очевидно, что это очень неэффективный способ. Сложность алгоритма O(n^2). При большом объеме входных данных, поиск пары числе может занять довольно длительное время, особенно если нужной пары просто не существует (кстати, этой ситуации никто не исключал).

Не станем приводить реализацию данного алгоритма. Здесь все и так понятно. Попробуем решить задачу более эффективно. 

### **Вариант 2, с сортировкой: O(n*log(n))**

Допустим, что мы отсортировали нашу последовательность. При этом сразу получаем сложность O(n*log(n)). Как теперь быстрее найти подходящую пару или сделать вывод, что такой пары не существует. Посмотрим внимательно на отсортированную последовательность (2):

<pre>-7, -6, -5, -4, -2, -1, 0, 1, 2, 3, 8  (2)</pre>

Тот факт, что элементы упорядочены, дает нам право "откидывать" из рассмотрения заведомо "неудовлетворительные" числа. Например, берем наименьшее число последовательности. Это -7\. Пару для -7 может составить только число 12, так как 12 + (-7) = 5. Обращаясь к другому "краю" последовательности, мы понимаем, что 12 у нас в наличии нет и быть не может. Наибольшее число равно 8. Таким образом, число -7 можно "выкинуть" из дальнейшего рассмотрения, ведь пары для него у нас точно не будет. Переходим к числу -6 и повторяем сравнение с наибольшим числом последовательности. И так далее. Откинув лишнее слева, получим:

<pre>-2, -1, 0, 1, 2, 3, 8  (3)</pre>

Число -2 откидывать пока нельзя, так как подходящая пара - это число 7, которое **может** присутствовать в нашей отсортированной последовательности (непосредственно перед 8-кой). Раз "откидывать" числа слева больше нельзя, переходим к правому краю, и повторяем аналогичные шаги: берем 8, парой будет число -3. Но на данный момент наименьшее число последовательности равно -2. Значит 8 "откидываем". Число 3 отбросить пока нельзя, поэтому снова переходим к левому краю.

В итоге, в данном примере всё сведется к единственно возможной паре чисел, которые в сумме дают 5:

<pre>2, 3  (4)</pre>

Ответ может быть найден и раньше. Допустим, что в последовательности чисел присутствует 7\. Тогда алгоритм остановится, когда последовательность будет вот в таком состоянии:
<pre>
-2, -1, 0, 1, 2, 3, 7  (5)

Ответом будут крайние числа: M = 7, а N = -2
</pre>
После сортировки достаточно всего лишь одного прохода, чтобы искомая пара чисел была найдена, а это значит что, сложность такого алгоритма целиком определяется сложностью задействованного алгоритма сортировки. То есть, раз сортировка имеет сложность O(n*log(n)), то и весь алгоритм будет иметь такую сложность.

Пример реализации описанного алгоритма на C++:
```
#include <list>
#include <iostream>
#include <iterator>

enum Side { LEFT = 0, RIGHT };

// strip - функция, которая может быть вызвана как для правого края, 
// так и для левого края. Условимся, что после сортировки
// последовательность возрастает слева направо. 
// Крайнее левое число - наименьшее, крайнее правое - наибольшое число.

// Если функция вернет true - алгоритм завершен, 
// иначе вызвать повторно для другого края

template<typename Value>
bool strip(Value K, std::list<Value>& cont, Side side)
{
    // Если в последовательности меньше двух элементов,
    // то закончить алгоритм
    if (cont.size() < 3) return true;
    
    if (side == LEFT) {
        
        // Обход последовательности со стороны наименьшего числа
        for (auto it = cont.begin(); it != cont.end(); ++it) {
            
            Value tmp = K - *it; // Вычисляем подходящую пару
            
            // Отброс неподходящих чисел
            if (tmp > cont.back()) continue;  
            
            // Нужно перейти к другому краю, так как с этого края
            // отбрасывать пока нельзя 
            else if (tmp < cont.back()) {     
                cont.erase(cont.begin(), it);
                return false;                
            }
            
            // Найде ответ! Закончить алгоритм
            else if (tmp == cont.back()) { 
                cont = {*it, cont.back()};
                return true;
            }
        }
    }
    else {
        
        // Обход последовательности со стороны наибольшего числа        
        for (auto it = cont.rbegin(); it != cont.rend(); ++it) {
            
            Value tmp = K - *it; // Вычисляем подходящую пару
            
            // Отброс неподходящих чисел            
            if (tmp < cont.front()) continue;
            
            // Нужно перейти к другому краю, так как с этого края
            // отбрасывать пока нельзя
            else if (tmp > cont.front()) {
                cont.erase(it.base(), cont.end());
                return false;
            }
            
            // Найде ответ! Закончить алгоритм
            else if (tmp == cont.front()) {
                cont = {cont.front(), *it};
                return true;
            }
        }
    }
    return true;
}


template<typename Value>
void find_2_number(Value K, std::list<Value> cont) {
    
    Side side = LEFT;
    
    // Сортировка
    cont.sort(); // n * log(n)
    // Поиск пары чисел
    while (!strip(K, cont, side)) side = side ? LEFT : RIGHT; // Еще n
    
    if (cont.size() == 2 && 
        cont.front() + cont.back() == K) {
        
        // Вывод ответа
        std::copy(cont.begin(), cont.end(), 
                  std::ostream_iterator<int>(std::cout, " ")); 
    }
    else {
        std::cout << "Not found";
    }
}


int main(int argc, char** argv) 
{
    // Тест
    std::list<int> lst = { 7, -1, 1, -7, 0, -4, 3, 2, -5, -6, 8 };
    find_2_number(5, lst);
}
```
_Стоит отметить, что, например, на языке Python этот алгоритм можно записать намного короче и понятнее. _

Итак, имеем сложность O(n*log(n)) - это хорошо! Однако отсутствие ограничений по памяти наталкивает нас на поиск еще более эффективного метода решения.

### **Вариант 3, быстрый: O(n)**

Количество элементов нам известно, памятью нас не ограничивают. Такие условия позволяют нам задействовать для решения задачи очень эффективную структуру данных \- хеш-таблицу. Важное свойство хеш-таблиц состоит в том, что, при некоторых разумных допущениях, поиск и вставка (и удаление) элементов в среднем выполняются за время O(1). Тогда наш алгоритм поиска двух чисел может быть таким:

1.  Берем очередной элемент из последовательности и вычисляем второе число, которое в сумме с текущим числом даст нам 5. 
2.  Ищем во вспомогательной хеш-таблице второе (рассчетное) число. Если такое число существует, то алгоритм останавливается, ответ найден. Иначе, добавляем рассматриваем элемент последовательности во вспомогательную хеш-таблицу. 
3.  Если в исходной последовательности еще есть нерассмотренные элементы, переходим к шагу 1\. Иначе, алгоритм останавливается, ответа не существует.

Все очень просто! При этом не нужно отсортировывать последовательность. Главное, чтобы в процессе выполнения алгоритма часто не возникали коллизии и рехэш хеш-таблицы. Для этого мы можем изменить значение **коэффициента заполнения хеш-таблицы** (max\_load\_factor) и сразу указать сколько элементов будет храниться в хэш-таблице (reserve). Эти действия гарантируют нам сложность операций с хеш-таблицей равную O(1). А это значит, что весь алгоритм будет иметь сложность O(n). 

Приятно что, реализация алгоритма также упрощается:
```
#include <list>
#include <unordered_set>
#include <iostream>

template<typename Value>
void find_2_number(Value K, std::list<Value> cont) {
    
    // Вспомогательная хеш-таблица
    std::unordered_set<Value> tbl;
    
    // Коэффициент заполнения
    tbl.max_load_factor(0.6);
    
    // Гарантируемая вместимость
    tbl.reserve(cont.size()); 
    
    for (Value& x : cont) {
        
        Value tmp = K - x; // Вычисляем подходящую пару
        
        // Возможно рассчетное число уже встречалось...
        auto p = tbl.find(tmp); 
        
        if (p == tbl.end()) {
            
            // Если нет, тогда сохраняем текущее число в хеш-таблице
            tbl.insert(x);
        }
        else {
            
            // Если да, значит ответ найден!
            std::cout << *p << ' ' << x <<  std::endl; 
            return;
        }
    }
    std::cout << "Not found" <<  std::endl;
}


int main(int argc, char** argv) 
{
    // Тест
    std::list<int> lst = { 7, -1, 1, -7, 0, -4, 3, 2, -5, -6, 8 };
    find_2_number(5, lst);
}
```
Напоследок, докажем, что данную задачу невозможно решить еще эффективнее.

### **Вариант 4, еще быстрее: ???**

Допустим дана последовательность неотсортированных целых чисел. Нужно найти два числа в последовательности, таких что их сумма была бы равна 5\. Представим, что есть алгоритм, который решает эту задачу эффективнее, чем O(n). Следовательно, не все элементы последовательности участвуют в алгоритме.

Тогда допустим, что решения для данной последовательности нет, то есть нет такой пары чисел, которые в сумме были бы равны 5\. Чтобы сделать такой вывод нужно проанализировать **все** **числа** последовательности, так как абсолютно любой элемент может участвовать в ответе. Следовательно, не может быть такого решения, которое **всегда **игнорировало бы какую-то часть элементов и имело сложность, например, O(log n).