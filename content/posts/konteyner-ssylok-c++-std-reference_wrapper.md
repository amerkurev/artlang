---
author: "Andrey Merkurev"
linktitle: "Контейнер ссылок в C++ или зачем нужен std::reference_wrapper?"
title: "Контейнер ссылок в C++ или зачем нужен std::reference_wrapper?"
publishDate: 2014-11-24T22:46:00+03:00
date: 2014-11-24T22:46:00+03:00
draft: false
tag: "c++, std, reference_wrapper, cref, ref"
oldLink: "/article/view/7/"
---


Прежде чем, тронуть **std::reference_wrapper** давайте рассмотрим несколько задач, некоторые из которых могут показаться странными на первый взгляд. 

**_Задача первая_**

Ссылки в C++ не могут выступать в качестве типа элементов массива или контейнера STL:
```
std::vector< std::string& > cont; // Ошибка на этапе компиляции
```
Конечно можно использовать указатели в качестве элементов контейнера, однако в этом случае оказывается задействован синтаксис указателей. Поэтому, иногда очень хочется организовать контейнер, хранящий ссылки. Как этого можно добиться? Читаем далее.

**_Задача вторая_**

Инициализация ссылки происходит при её объявлении. После объявления ссылки её невозможно привязать к другой переменной. Однако можно легко создать похожее по семантике поведение и сделать что-то вроде "повторной инициализации" ссылки.

**_Задача третья_**

Многие алгоритмы в STL могут принимать функторы (функциональные объекты) в качестве своих аргументов. Передача аргументов алгоритму, в том числе и функторов, происходит по значению. Это затрудняет использование внутреннего состояния функторов. К примеру: как подсчитать количество операций сравнения в алгоритме **std::sort**?

Решим все эти задачи.

Начнем давать ответы в обратном порядке.

### **Задача третья \- ответ**

Третья задача решается с помощью шаблонных функций **std::ref** и **std::cref** объявленных в заголовке <functional>. Первая возвращает ссылку на объект, вторая возвращает константную ссылку. Эти функции очень часто нужны при работе, например, с std::bind. Причина одна - передать в связыватель ссылку, а не копию объекта. Если Вы работаете с потоками (std::thread) и Вам нужно передать аргументы по ссылке при инициализации объекта потока, Вам также понадобятся функции **std::ref **и **std::cref**.
```
// Создаем "обещание"
std::promise< std::string > p; 

// Передаем "обещаение" по ссылке, так как копировать его нельзя!
std::thread t(func, std::ref(p)); 
```
Для того, чтобы подсчитать количество операций сравнения в алгоритме **std::sort**, можно также воспользоваться функциями **std::ref **или **std::cref**. В этом случае, функтор будет передан по ссылке, и мы сможем использовать его внутреннее состояние, как внутри алгоритма, так и после его завершения. Пример ниже:
```
#include <vector>
#include <algorithm>
#include <iterator>
#include <iostream>
#include <functional>


template<typename T>
struct SortPredicate
{
    // Счетчик (внутреннее состояние)
    uint64_t count;
    
    // Инициализация счетчика
    SortPredicate() : count(0) {}
    
    bool operator()(T a, T b) {
        // Подсчет операций сравнения
        ++count; 
        return a < b;
    }
};

int main(int argc, char** argv)
{
    std::vector<int> v = {7,3,8,5,4,6,1,9,2};
    
    // Создаем функтор-предикат, который считает "сравнения"
    SortPredicate<int> p;
    
    // Используем std::ref, чтобы передать функтор по ссылке, а не по значению
    std::sort(v.begin(), v.end(), std::ref(p));
    
    // Вывод на экран количества сравнений (получилось 28)
    std::cout << p.count << std::endl;
    return 0;
}
```
Аналогичные примеры можно привести и для других алгоритмов STL. То что, это актуальная задача подтверждает, тот факт, что алгоритм std::for\_each возвращает свой функтор. И мы можем работать с ним после выполнения алгоритма. Но так делает только std::for\_each. Для остальных алгоритмов можно использовать описанный подход с **std::ref **и **std::cref**.

Пришло время открыть "магию" функций **std::ref **и **std::cref**, и узнать, как они обеспечивают передачу аргументов по ссылке. Лучше всего будет взглянуть на их реализацию, например, в GCC:
```
// находимся в пространстве std в заголовке <functional>

template<typename _Tp>
inline reference_wrapper<_Tp>
ref(_Tp& __t)
{ 
    return reference_wrapper<_Tp>(__t); 
}
 

template<typename _Tp>
inline reference_wrapper<const _Tp>
cref(const _Tp& __t)
{ 
    return reference_wrapper<const _Tp>(__t); 
}
```
Оказывается, **std::ref **и **std::cref **почти ничего и не делают. Принимая свой аргумент по ссылке или константной ссылке, они создают экземпляр типа **reference_wrapper** и просто возвращают созданный объект. Именно этот объект далее и будет передан в качестве аргумента. Но как тип **reference_wrapper** "эмулирует" нужные нам ссылки? Лучше один раз увидеть, чем долго про это рассказывать, поэтому снова обратимся к GCC и посмотрим реализацию шаблона класса **reference_wrapper**. Чтобы не потерять сути, немного упростим данную реализацию, скрыв один интересный момент. Итак, **reference_wrapper**:
```
template<typename _Tp>
class reference_wrapper
{
    _Tp* _M_data; // Указатель на объект типа _Tp
 
public:
    typedef _Tp type;
 
    // Конструктор из ссылки на объект типа _Tp
    reference_wrapper(_Tp& __indata)
       : _M_data(std::addressof(__indata))
       { }
 
    // Копирующий конструктор
    reference_wrapper(const reference_wrapper<_Tp>& __inref):
       _M_data(__inref._M_data)
       { }
 
    // Оператор присваения
    reference_wrapper&
    operator=(const reference_wrapper<_Tp>& __inref)
    {
        _M_data = __inref._M_data;
        return *this;
    }
 
    // Оператор приведения типа к _Tp&
    operator _Tp&() const
    { 
        return this->get(); 
    }
 
    // Вспомогательный метод: возвращает ссылку на "обёрнутый" объект
    _Tp& get() const
    { 
        return *_M_data; 
    }
    
    // Несколько интересных мест было опущено, чтобы сохранить суть.
    // Обязательно посмотрите полную реализацию.
};
```
Это простой шаблон класса, который хранит внутри себя указатель на данные. Получив ссылку в конструкторе, **reference_wrapper** узнает адрес переменной **__indata** с помощью функции **std::addressof<>** (эта функция была очень хорошо описана на ArtLang [здесь](http://artlang.net/article/view/2/)). У **reference_wrapper** определены копирующий конструктор и оператор присваения, а это значит что объекты этого типа могут легко инициализироваться повторно в отличии от ссылкок. Ну и самое главное, определен оператор приведения к ссылке на тип _Tp. Т.е. в нужный момент **reference_wrapper** ведет себя как необходимая нам ссылка. То что нужно!

Итак, когда мы используем для передачи аргумента функции **std::ref **или **std::cref**, мы передаем не копию объекта, не ссылку на него, а экземпляр **reference_wrapper**, который внутри себя хранит указатель на передаваемый объект.

### **Задача вторая \- ответ**

Инициализация ссылки происходит при её объявлении. После объявления ссылки её невозможно привязать к другой переменной. Однако можно легко создать похожее по семантике поведение, если использовать **reference_wrapper**. Покажем это на примере. 

Допустим есть список, который хранит 10000 строк std::string. Необходимо найти самую длинную строку (в которой больше всего символов). Список не отсортирован по этому критерию. Будем использовать метод прямого перебора и хранить самую длинную строку во временной переменной. При этом желательно избежать копирования строк во временную переменную. Конечно для этого можно, в качестве временной переменной, взять итератор списка, но мы возьмем объект **reference_wrapper**. Пример ниже:
```
#include <list>
#include <string>
#include <functional>
#include <iostream>

int main(int argc, char** argv)
{
    // Вводим новое имя для типа 
    typedef std::reference_wrapper<std::string> string_ref;
    
    // Список, в котором очень много строк
    std::list<std::string> l; 
    
    // Временная переменная, а-ля "ссылка" на std::string
    string_ref t = l.front();
    
    // Очень простой цикл без синтаксиса указетелей и итераторов
    for (std::string& x : l) {
        if (x.size() > t.get().size()) t = x; // Копирования не происходит! 
    }
    
    // Вывод результата
    std::cout << t.get();
    return 0;
}
```
Пример достаточно надуманный, однако, он наглядно демонстрирует, как легко повторно инициализировать **reference_wrapper**. Обратите внимание на то, что когда компилятор не может привести тип, приходится вызывать метод get(). Этот метод явно возвращает ссылку на "обернутый" объект. Если представить на секунду, что вызова get() можно было бы избежать, то мы бы даже не смогли отличить настоящие ссылки, от объектов  **reference_wrapper **! 

  

### **Задача первая \- ответ**

Контейнерные классы STL реализуют семантику значений, а не ссылок. Контейнеры создают копии элементов, которые они содержат. Но, если копирование элементов требует избыточных затрат ресурсов, или нужно, чтобы несколько контейнеров размещали одни и теже элементы - приходится использовать "умные" указатели. Но есть и другой вариант. Использование **reference_wrapper**. 

Рассмотрим пример, в котором контейнер std::vector, хранит "ссылки" (объекты **reference_wrapper**). Пример взят с сайта [cppreference.com](http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper):
```
#include <algorithm>
#include <list>
#include <vector>
#include <iostream>
#include <functional>
 
int main()
{
    // Исходный контейнер с элементами типа int
    std::list<int> l = {-4, -3, -2, -1, 0, 1, 2, 3, 4};
 
    // Контейнер, хранящий "ссылки" на элементы первого контейнера
    std::vector<std::reference_wrapper<int>> v(l.begin(), l.end());
    
    // Перемешиваем "ссылки", но не сами элементы
    std::random_shuffle(v.begin(), v.end());
 
    // Печатаем элементы исходного контейнера
    std::cout << "Contents of the list: ";
    for (int n : l) {
        std::cout << n << ' ';
    }
    std::cout << '\n';
 
    // Печатаем элементы через ссылки на них. Ссылки перемешаны
    std::cout << "Contents of the list, shuffled: ";
    for (int i : v) {
        std::cout << i << ' ';
    }
    std::cout << '\n';
 
    // Умножаем на 2 каждый элемент в исходном контейнере
    std::cout << "Doubling the values in the initial list...\n";
    for (int &i : l) {
        i *= 2;
    }
 
    // Через "контейнер ссылок" получаем актуальные значения элементов
    std::cout << "Shuffled vector actually contains references: ";
    for (int i : v) {
        std::cout << i << ' ';
    }
    std::cout << '\n';
}
```
Вывод программы:
<pre>
Contents of the list: -4 -3 -2 -1 0 1 2 3 4 
Contents of the list, shuffled: 0 -1 3 4 -4 1 -2 -3 2 
Doubling the values in the initial list...
Shuffled vector actually contains references: 0 -2 6 8 -8 2 -4 -6 4
</pre>
Используя такие "контейнеры ссылок", Вы всегда должны гарантировать, что элементы, на которые Вы ссылаетесь, существуют. Если в этом примере контейнер std::list вдруг внезапно будет уничтожен, пользоваться "контейнером ссылок" (std::vector) будет уже нельзя.

Преимущество этого кода заключается в том, что не используется синтаксис указателей. Даже вызова get() удалось избежать.

В заключение хотелось бы сказать: **reference_wrapper** возможно не очень популярная "штука" из STL, но Вы врядли сможете избежать её использования в своих программах. Хотя бы косвенно - через вызовы **std::ref** и **std::cref** \- но Вы задействуете эту простую обертку вокруг обычных указателей.